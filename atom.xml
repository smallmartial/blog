<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>smallmartial&#39;s blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://github.com/smallmartial/blog.git/"/>
  <updated>2019-04-10T06:29:33.637Z</updated>
  <id>https://github.com/smallmartial/blog.git/</id>
  
  <author>
    <name>小武</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springcloud</title>
    <link href="https://github.com/smallmartial/blog.git/2019/04/09/springcloud/"/>
    <id>https://github.com/smallmartial/blog.git/2019/04/09/springcloud/</id>
    <published>2019-04-09T13:44:42.000Z</published>
    <updated>2019-04-10T06:29:33.637Z</updated>
    
    <content type="html"><![CDATA[<p>添加图片<br><img src="/smallmartial/blog.git/2019/04/09/springcloud/love.jpg" alt="love"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;添加图片&lt;br&gt;&lt;img src=&quot;/smallmartial/blog.git/2019/04/09/springcloud/love.jpg&quot; alt=&quot;love&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>springboot一</title>
    <link href="https://github.com/smallmartial/blog.git/2019/04/07/springboot%E4%B8%80/"/>
    <id>https://github.com/smallmartial/blog.git/2019/04/07/springboot一/</id>
    <published>2019-04-07T11:16:20.000Z</published>
    <updated>2019-04-07T11:51:38.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Springboot整合Mybatis"><a href="#Springboot整合Mybatis" class="headerlink" title="Springboot整合Mybatis"></a>Springboot整合Mybatis</h2><p>SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis<a href="https://github.com/mybatis/spring-boot-starter">官网</a>自己实现了：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line"> # configuration:</span><br><span class="line">    #map-underscore-to-camel-case: true</span><br><span class="line">  #mapper-locations: mapper/*.xml</span><br><span class="line">type-aliases-package: cn.smallmartial.springbootdemo.pojo</span><br><span class="line"># mapper.xml文件位置,如果没有映射文件，请注释掉</span><br><span class="line">mybatis.mapper-locations=classpath:mappers/*.xml</span><br></pre></td></tr></table></figure><p>关于配置文件中华mybaits的configuration中 如果没有内容，需要注释掉否则会报错，笔者太菜，查阅很长时间才找到错误所在。</p><h3 id="通用mapper配置"><a href="#通用mapper配置" class="headerlink" title="通用mapper配置"></a>通用mapper配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>通用Mapper都可以极大的方便开发人员。可以随意的按照自己的需要选择通用方法，还可以很方便的开发自己的通用方法。<br>极其方便的使用MyBatis单表的增删改查。支持单表操作，<br>不支持通用的多表联合查询。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>继承通用的Mapper<t>，必须指定泛型<t>,导包需要导入tk.mybaits中的包。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tk.mybatis.mapper.common.Mapper;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></p><p>通用mapper中含有单表的增删改查<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据T对象中的属性名称查询,类似于select * from table where t.username=xxx and t.mobile = xxxx</span></span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">select</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如果断定T对象的查询条件是一个,可以调用此方法,返回单个对象</span></span></span><br><span class="line"><span class="function">T <span class="title">selectOne</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//根据主键查询</span></span></span><br><span class="line"><span class="function">T <span class="title">selectByPrimaryKey</span><span class="params">(Object id)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//根据主键更新数据,T对象里面有什么属性就更新什么属性,如果T对象没有主键,抛出异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//根据主键更新数据,需要把对象中所有的字段全部填充才能调用此方法,一般不常用!</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据主键更新数据,T对象里面有什么属性就更新什么属性,如果T对象没有主键,抛出异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//插入数据,需要有主键,有什么属性插入什么属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//插入数据,需要有主键,需要数据库表中的所有字段全都存在,否则插入失败,此方法不常用</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据条件删除数据,原理同select(T)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据主键删除</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(T t)</span></span></span><br></pre></td></tr></table></figure></p><p>测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = userMapper.selectByPrimaryKey(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(<span class="string">"user = "</span>+ user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用的是springboot开发，导入测试方法选择springboot中所集成的测试类，在需要测测试方法中使用@SpringBootTest。<br>service层实现方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>controller层实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">hello</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">       <span class="comment">// System.out.println("hello methd is running");</span></span><br><span class="line">        <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>项目运行结果：<br><img src="/smallmartial/blog.git/2019/04/07/springboot一/images/a.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Springboot整合Mybatis&quot;&gt;&lt;a href=&quot;#Springboot整合Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Springboot整合Mybatis&quot;&gt;&lt;/a&gt;Springboot整合Mybatis&lt;/h2&gt;&lt;p&gt;Sp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA知识点总结一</title>
    <link href="https://github.com/smallmartial/blog.git/2019/04/02/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E4%B8%80/"/>
    <id>https://github.com/smallmartial/blog.git/2019/04/02/JAVA知识点总结一/</id>
    <published>2019-04-02T06:26:04.000Z</published>
    <updated>2019-04-02T07:21:59.567Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-HashMap和HashTable的描述"><a href="#1-HashMap和HashTable的描述" class="headerlink" title="1.HashMap和HashTable的描述"></a>1.HashMap和HashTable的描述</h3><ul><li>他们都实现了Map接口</li><li>HashMap非线程安全，在多个线程访问Hashtable时，不需要自己为他的方法实现同步，而HashMap必须为此提供额外的同步。</li><li>HashMap允许将null作为一个entry的key或者value,而Hashtable不允许。</li><li>HashMap无contains方法<h3 id="2-在java7中，不用用作switch参数的类型是浮点型"><a href="#2-在java7中，不用用作switch参数的类型是浮点型" class="headerlink" title="2.在java7中，不用用作switch参数的类型是浮点型"></a>2.在java7中，不用用作switch参数的类型是浮点型</h3></li><li>switch语句后控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float、double、boolean类型，String类型是java7支持的。<h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3></li><li>ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表的数据结构</li><li>对于随机访问get和set,ArrayList优于LinkedList,因为LinkedList要移动指针</li><li>对于新增和删除操作add和remove,LinkedList比较占优势,因为ArrayList要移动资源</li><li>ArrayList的空间浪费主要体现在list列表的结构预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个都需要消耗相当的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-HashMap和HashTable的描述&quot;&gt;&lt;a href=&quot;#1-HashMap和HashTable的描述&quot; class=&quot;headerlink&quot; title=&quot;1.HashMap和HashTable的描述&quot;&gt;&lt;/a&gt;1.HashMap和HashTable的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SSM知识总结</title>
    <link href="https://github.com/smallmartial/blog.git/2019/03/30/SSM%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/smallmartial/blog.git/2019/03/30/SSM知识总结/</id>
    <published>2019-03-30T08:19:43.000Z</published>
    <updated>2019-03-30T09:06:42.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSM重点知识"><a href="#SSM重点知识" class="headerlink" title="SSM重点知识"></a>SSM重点知识</h1><h2 id="SpringMVC-DispatcherServlet"><a href="#SpringMVC-DispatcherServlet" class="headerlink" title="SpringMVC:DispatcherServlet"></a>SpringMVC:DispatcherServlet</h2><ul><li>DispatcherServlet是SpringMVC的心脏，它负责接收 HTTP 请求并协调 Spring MVC 的各个组件完成请求处理的工作。DispatcherServlet 本质也是一个 Servlet，用户必须在 web.xml 中配置。</li></ul><h3 id="DispatcherServlet-可以分为三个功能"><a href="#DispatcherServlet-可以分为三个功能" class="headerlink" title="DispatcherServlet 可以分为三个功能"></a>DispatcherServlet 可以分为三个功能</h3><ul><li>截获Http请求，交给SpringMVC框架处理</li><li>处理 控制层、业务层、持久层之间的调用关系</li><li>初始化并装配SpringMVC的各个组件</li></ul><h3 id="配置DispatcherServlet"><a href="#配置DispatcherServlet" class="headerlink" title="配置DispatcherServlet"></a>配置DispatcherServlet</h3><p>在web.xml中配置一个Servlet,并通过<servlet-mappting>指定处理的URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;spring-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml</span><br><span class="line">      Mybatis - &gt; spring -&gt; springmvc --&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;spring-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">  &lt;!-- 默认匹配所有的请求 --&gt;</span><br><span class="line">  &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></servlet-mappting></p><h3 id="截获HTTP请求"><a href="#截获HTTP请求" class="headerlink" title="截获HTTP请求"></a>截获HTTP请求</h3><p> 通过 &lt; servlet-mapping&gt; 指定 DispatcherServlet 处理所有的 HTTP 请求，这里的“/”表示浏览器中的 URL 都会被 DispatcherServlet 接收。大多数情况，我们都会让 DispatcherServlet 处理以某种特定的 URL，比如以 .html 为后缀的 HTTP 请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;spring-dispatcher&lt;/servlet-name&gt;</span><br><span class="line">  &lt;!-- 默认匹配所有的请求 --&gt;</span><br><span class="line">  &lt;url-pattern&gt;/*.html&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><h2 id="Spring-IOC和AOP"><a href="#Spring-IOC和AOP" class="headerlink" title="Spring:IOC和AOP"></a>Spring:IOC和AOP</h2><pre><code>在面向切片编成中,IOC和AOP是spring的灵魂。</code></pre><ul><li><p>IOC:控制反转也叫依赖注入。利用了工厂模式，将对象交给容器管，只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。</p></li><li><p>AOP：面向切面编程（典型的代理模式）AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p></li><li><p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</p></li><li><p>AOP的特性: 1.各个步骤之间的良好隔离性。2.源代码无关性</p></li></ul><h2 id="MyBatis-ORM"><a href="#MyBatis-ORM" class="headerlink" title="MyBatis:ORM"></a>MyBatis:ORM</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>Java程序是通过JDBC(Java Data Base Connectivity)连接数据库的，JDBC是由SUN公司提出的一系列规范，但是它只定义了接口的规范，而具体的实现是交给了各个数据库厂商去实现的，JDBC是一种典型的桥接模式.</p><h3 id="JDBC编写步骤"><a href="#JDBC编写步骤" class="headerlink" title="JDBC编写步骤"></a>JDBC编写步骤</h3><ul><li>使用JDBC编程需要连接数据库，注册驱动和数据库信息</li><li>操作Connection,打开Statement对象</li><li>通过Statement执行SQL,返回结果到ResultSet对象</li><li>使用ResultSet读取数据，然后通过代码转换为具体的POJO对象</li><li>关闭数据库相关资源</li></ul><h3 id="JDBC弊端"><a href="#JDBC弊端" class="headerlink" title="JDBC弊端"></a>JDBC弊端</h3><ul><li>工作量大</li><li>编程复杂</li></ul><h3 id="ORM模型"><a href="#ORM模型" class="headerlink" title="ORM模型"></a>ORM模型</h3><ul><li><p>ORM取代了JDBC,所有的ORM模型都是基于JDBC进行封装的，不同ORM模型对JDBC封装的强度是不一样的</p></li><li><p>对象关系映射(Object Relational Mapping),简单的说ORM框架就是数据库的表和简单Java对象的映射关系模型，我们通过这层映射关系就可以简单迅速地把数据库表的数据转化为POJO</p></li></ul><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>mybatis是一个java持久层框架，它封装少、高性能·可优化、维护简单等优点成为了目前java移动互联网网站服务的首选持久层框架，它特别适合分布式和大数据网络数据库编程<br>之所以称它为半自动，是因为它需要手工匹配提供POJO、SQL和映射关系，而全表映射的Hibernate只需要提供POJO和映射关系便可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSM重点知识&quot;&gt;&lt;a href=&quot;#SSM重点知识&quot; class=&quot;headerlink&quot; title=&quot;SSM重点知识&quot;&gt;&lt;/a&gt;SSM重点知识&lt;/h1&gt;&lt;h2 id=&quot;SpringMVC-DispatcherServlet&quot;&gt;&lt;a href=&quot;#Spring
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小武的博客</title>
    <link href="https://github.com/smallmartial/blog.git/2019/03/29/hello-world/"/>
    <id>https://github.com/smallmartial/blog.git/2019/03/29/hello-world/</id>
    <published>2019-03-29T12:05:50.000Z</published>
    <updated>2019-03-30T08:20:57.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介:"></a>作者简介:</h2><pre><code>小武一名大三学生，目前很丧中...            我本楚狂人，凤歌笑孔丘   the whole of life becomes an act of letting go,    but what always hurts the most is not taking a moment to say goodbye</code></pre><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><pre><code>有一种孤独是原以为找到一个能与自己分享的痛苦的人很难,后来才发现找到一个能分享自己喜悦的人更难。爱自己是终生浪漫的开始,我们一直在坚持着，不是为了改变这个世界，而是希望不被这个世界所改变。</code></pre><h2 id="我们站在巨人的肩膀上"><a href="#我们站在巨人的肩膀上" class="headerlink" title="我们站在巨人的肩膀上"></a>我们站在巨人的肩膀上</h2><pre><code>. 和一些人的关系就像平行线，一辈子相守相望，见于眼底藏于心间。. 就怕耐不住寂寞，冲动而成了相交线，在一个点尽情拥抱，  从此便离得越来越远，再也不见。. 遇见这样的人，因为不想做恋人只能一时，所以才选择做朋友能一世。</code></pre><h2 id="Here-with-you"><a href="#Here-with-you" class="headerlink" title="Here with you"></a>Here with you</h2><pre><code>I love three things in this world.Sun,Moon and You.Sun for moring,Moon for night, and you forever.浮世三千，吾爱有三日、月与卿。日为朝，月为暮卿为朝朝暮暮</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作者简介&quot;&gt;&lt;a href=&quot;#作者简介&quot; class=&quot;headerlink&quot; title=&quot;作者简介:&quot;&gt;&lt;/a&gt;作者简介:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;小武一名大三学生，目前很丧中...
            我本楚狂人，凤歌笑孔丘

   the wh
      
    
    </summary>
    
    
  </entry>
  
</feed>
